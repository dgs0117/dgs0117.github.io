<!DOCTYPE HTML>
<html lang="en">

<head>
    <!--Setting-->
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta name="renderer" content="webkit|ie-comp|ie-stand">
    <meta name="apple-mobile-web-app-capable" content="zljzy">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="format-detection" content="telephone=no,email=no,adress=no">
    <meta name="browsermode" content="application">
    <meta name="screen-orientation" content="portrait">
    <meta name="theme-version" content="1.2.3">
    <meta name="root" content="/">
    <link rel="dns-prefetch" href="http://yoursite.com">
    <!--SEO-->

<meta name="keywords" content="多线程" />


<meta name="description" content="ReentrantLock源码分析一、构造函数123456789ReentrantLock lock = new ReentrantLock();//里面的参数可指定是公平还是非公平锁   pu..." />


<meta name="robots" content="all" />
<meta name="google" content="all" />
<meta name="googlebot" content="all" />
<meta name="verify" content="all" />
    <!--Title-->

<title>
    
    ReentrantLock源码分析 |
    
    zljzy
</title>

<link rel="alternate" href="/atom.xml" title="zljzy" type="application/atom+xml">


<link rel="icon" href="/favicon.ico">

    

<link rel="stylesheet" href="/css/bootstrap.min.css?rev=3.3.7">
<link rel="stylesheet" href="/css/font-awesome.min.css?rev=4.7.0">
<link rel="stylesheet" href="/css/style.css?rev=@@hash">
    
<div class="hide">
    <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? " https://" : " http://");
    document.write(unescape("%3Cspan class='cnzz_stat_icon_1263868967 hide' %3E%3Cscript%20src%3D%22https%3A%2F%2Fs95.cnzz.com%2Fz_stat.php%3Fweb_id%3D1272564536%22%3E%3C%2Fscript%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "s19.cnzz.com/z_stat.php%3Fid%3D1263868967%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script>
</div>




    

</head>
<!--[if lte IE 8]>
<style>
    html{ font-size: 1em }
</style>
<![endif]-->
<!--[if lte IE 9]>
<div style="ie">你使用的浏览器版本过低，为了你更好的阅读体验，请更新浏览器的版本或者使用其他现代浏览器，比如Chrome、Firefox、Safari等。</div>
<![endif]-->
<body>
    <header class="main-header"  style="background-image:url(
    http://snippet.shenliyang.com/img/banner.jpg)"
     >
    <div class="main-header-box">
        <a class="header-avatar" href="/" title='JunHui Gao'>
            <img src="/img/avatar.jpg" alt="logo头像" class="img-responsive center-block">
        </a>
        <div class="branding">
            <!--<h2 class="text-hide">Snippet主题,从未如此简单有趣</h2>-->
            
            <h2>
                求知若饥，虚心若愚
            </h2>
            
        </div>
    </div>
</header>
    <nav class="main-navigation">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="navbar-header"><span class="nav-toggle-button collapsed pull-right" data-toggle="collapse" data-target="#main-menu" id="mnav">
                        <span class="sr-only"></span>
                        <i class="fa fa-bars"></i>
                    </span>
                    <a class="navbar-brand" href="http://yoursite.com">
                        zljzy</a>
                </div>
                <div class="collapse navbar-collapse" id="main-menu">
                    <ul class="menu">
                        
                        <li role="presentation" class="text-center">
                            <a href="/"><i class="fa "></i>
                                Home</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/document/"><i class="fa "></i>
                                文档</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/food/"><i class="fa "></i>
                                美食</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/tool/"><i class="fa "></i>
                                工具</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/categories/health/"><i class="fa "></i>
                                养生</a>
                        </li>
                        
                        <li role="presentation" class="text-center">
                            <a href="/archives/"><i class="fa "></i>
                                时间轴</a>
                        </li>
                        
                    </ul>
                </div>
            </div>
        </div>
    </div>
</nav>
    <section class="content-wrap">
        <div class="container">
            <div class="row">
                <main class="col-md-8 main-content m-post">
                    <p id="process"></p>
<article class="post">
    <div class="post-head">
        <h1 id="ReentrantLock源码分析">
            
            ReentrantLock源码分析
            
        </h1>
        <div class="post-meta">
    
    <span class="categories-meta fa-wrap">
        <i class="fa fa-folder-open-o"></i>
        <a class="category-link" href="/categories/document/">document</a>
    </span>
    
    
    <span class="fa-wrap">
        <i class="fa fa-tags"></i>
        <span class="tags-meta">
            
            <a class="tag-link" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" rel="tag">多线程</a>
            
        </span>
    </span>
    
    
    
    <span class="fa-wrap">
        <i class="fa fa-clock-o"></i>
        <span class="date-meta">
            2019/11/25</span>
    </span>
    
    
</div>
        
        
    </div>
    
    <div class="post-body post-content">
        <h3 id="ReentrantLock源码分析"><a href="#ReentrantLock源码分析" class="headerlink" title="ReentrantLock源码分析"></a>ReentrantLock源码分析</h3><h4 id="一、构造函数"><a href="#一、构造函数" class="headerlink" title="一、构造函数"></a>一、构造函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ReentrantLock lock = new ReentrantLock();//里面的参数可指定是公平还是非公平锁</span><br><span class="line"></span><br><span class="line">   public ReentrantLock() &#123;</span><br><span class="line">       sync = new NonfairSync();</span><br><span class="line">   &#125;</span><br><span class="line">   //指定是当前是公平锁 还是非公平锁</span><br><span class="line">   public ReentrantLock(boolean fair) &#123;</span><br><span class="line">       sync = fair ? new FairSync() : new NonfairSync();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>继承关系</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">static final class FairSync extends Sync &#123;&#125;</span><br><span class="line"></span><br><span class="line">static final class NonfairSync extends Sync &#123;&#125;</span><br><span class="line"> </span><br><span class="line">abstract static class Sync extends AbstractQueuedSynchronizer&#123;&#125;</span><br><span class="line"> </span><br><span class="line"> public abstract class AbstractQueuedSynchronizer extends  	             AbstractOwnableSynchronizer&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二、AQS数据结构分析"><a href="#二、AQS数据结构分析" class="headerlink" title="二、AQS数据结构分析"></a>二、AQS数据结构分析</h4><p>AQS（java.util.concurrent.locks.AbstractQueuedSynchronizer）是ReentrantLock实现线程排队等待的数据结构，本质是一个双向的FIFO队列；</p>
<h5 id="1、node提供的常量"><a href="#1、node提供的常量" class="headerlink" title="1、node提供的常量"></a>1、node提供的常量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">/** Marker to indicate a node is waiting in shared mode */</span><br><span class="line">       static final Node SHARED = new Node();//共享模式，表示可以多个线程同时执行</span><br><span class="line">       /** Marker to indicate a node is waiting in exclusive mode */</span><br><span class="line">       static final Node EXCLUSIVE = null;//独占模式，表示只有一个线程能执行例如ReentrantLock；共享模式 多个线程可同时执行 例如Semaphore/CountDownLatch</span><br><span class="line"></span><br><span class="line">       /** waitStatus value to indicate thread has cancelled. */</span><br><span class="line">       static final int CANCELLED =  1;//取消状态 表示这个节点被取消了 可能是主动取消或者被动取消，后续这个节点可能会被踢出队列</span><br><span class="line">       /** waitStatus value to indicate successor&apos;s thread needs unparking. */</span><br><span class="line">       static final int SIGNAL    = -1;//通知后继节点 表示这个结点执行完成以后，需要通知唤醒后继的结点</span><br><span class="line">       /** waitStatus value to indicate thread is waiting on condition. */</span><br><span class="line">       static final int CONDITION = -2;//说明这个结点因为被某一个condition挂起了</span><br><span class="line">       /**</span><br><span class="line">        * waitStatus value to indicate the next acquireShared should</span><br><span class="line">        * unconditionally propagate.</span><br><span class="line">        */</span><br><span class="line">       static final int PROPAGATE = -3;//在共享模式下，下一次获取锁后可以无限传播</span><br></pre></td></tr></table></figure>

<h5 id="2、node提供的变量"><a href="#2、node提供的变量" class="headerlink" title="2、node提供的变量"></a>2、node提供的变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">waitStatus 当前结点的状态，默认是0，可以是CANCELL、SIGNAL 等</span><br><span class="line">prev 前继结点</span><br><span class="line">next 后继结点</span><br><span class="line">thread 对应的线程</span><br><span class="line">nextWaiter 下一个等待condition的结点</span><br><span class="line">state 状态；是一个int值，表示当前线程占用资源的数量；0表示空闲，没有线程占用；ReentrantLock的state表示线程重入锁的次数</span><br></pre></td></tr></table></figure>
<h4 id="二、Lock"><a href="#二、Lock" class="headerlink" title="二、Lock"></a>二、Lock</h4><h5 id="1、NonfairSync-非公平锁"><a href="#1、NonfairSync-非公平锁" class="headerlink" title="1、NonfairSync 非公平锁"></a>1、NonfairSync 非公平锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line">public void lock() &#123;</span><br><span class="line">       //当为非公平锁时 这里的lock会走NonfairSync下的lock函数</span><br><span class="line">       sync.lock();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   final void lock() &#123;</span><br><span class="line">           //利用CAS更新当前锁的状态 分析1</span><br><span class="line">           if (compareAndSetState(0, 1))</span><br><span class="line">               //设置当前线程为独占锁的拥有者 分析2</span><br><span class="line">               setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">           else</span><br><span class="line">               //如果CAS更新失败 获取锁  分析3</span><br><span class="line">               acquire(1);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   ===&gt;分析1</span><br><span class="line">   //AbstractQueuedSynchronizer下方法；通过CAS更新当前锁的状态</span><br><span class="line">   protected final boolean compareAndSetState(int expect, int update) &#123;</span><br><span class="line">       return U.compareAndSwapInt(this, STATE, expect, update);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   ===&gt;分析2</span><br><span class="line">   //如果CAS更新成功，设置当前线程为独占锁的拥有者</span><br><span class="line">   //AbstractOwnableSynchronizer中方法；</span><br><span class="line">   //AbstractOwnableSynchronizer把AQS包了一层；主要提供了一些获取、设置当前独占锁拥有者</span><br><span class="line">   protected final void setExclusiveOwnerThread(Thread thread) &#123;</span><br><span class="line">       exclusiveOwnerThread = thread;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   ===&gt;分析3</span><br><span class="line">   //如果CAS更新失败 尝试获取锁</span><br><span class="line">   //AQS中的方法</span><br><span class="line">   public final void acquire(int arg) &#123;</span><br><span class="line">       //如果获取锁失败 阻塞排队 </span><br><span class="line">       if (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">           acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">           //如果排队也失败了 中断自己</span><br><span class="line">           selfInterrupt();</span><br><span class="line">   &#125;</span><br><span class="line">   //tryAcquire是AQS中的方法，由子类具体实现；这里看NonfairSync的tryAcquire</span><br><span class="line">   protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">           return nonfairTryAcquire(acquires); 、</span><br><span class="line">   &#125;</span><br><span class="line">   //acquires 是1</span><br><span class="line">   final boolean nonfairTryAcquire(int acquires) &#123;</span><br><span class="line">           final Thread current = Thread.currentThread();</span><br><span class="line">           int c = getState();//获取state值</span><br><span class="line">           if (c == 0) &#123;</span><br><span class="line">               //如果当前没有线程占用锁 通过CAS更新state标志位</span><br><span class="line">               //(这里也是非公平锁的一个原因 不判断前面是否有其它节点 直接CAS尝试拿锁)</span><br><span class="line">               if (compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                   //将当前线程设置为独占锁的拥有者</span><br><span class="line">                   setExclusiveOwnerThread(current);</span><br><span class="line">                   return true;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           //如果state不为0 并且当前线程就是独占锁的拥有者（表示重入）</span><br><span class="line">           else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">               //累加state</span><br><span class="line">               int nextc = c + acquires;</span><br><span class="line">               if (nextc &lt; 0) // overflow</span><br><span class="line">                   throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">               setState(nextc);</span><br><span class="line">               return true;</span><br><span class="line">           &#125;</span><br><span class="line">           return false;</span><br><span class="line">   &#125;</span><br><span class="line">   //新节点入队方法</span><br><span class="line">   private Node addWaiter(Node mode) &#123;</span><br><span class="line">       Node node = new Node(mode);</span><br><span class="line"></span><br><span class="line">       for (;;) &#123;//通过阻塞的方式将当前的node入队</span><br><span class="line">           Node oldTail = tail;//获取尾结点</span><br><span class="line">           if (oldTail != null) &#123;</span><br><span class="line">               //将新节点插入到队列尾部</span><br><span class="line">               U.putObject(node, Node.PREV, oldTail);</span><br><span class="line">               if (compareAndSetTail(oldTail, node)) &#123;</span><br><span class="line">                   oldTail.next = node;</span><br><span class="line">                   return node;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               //队列为空 初始化队列</span><br><span class="line">               initializeSyncQueue();</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   //将当前线程入队阻塞</span><br><span class="line">   final boolean acquireQueued(final Node node, int arg) &#123;</span><br><span class="line">       try &#123;</span><br><span class="line">           boolean interrupted = false;</span><br><span class="line">           for (;;) &#123;</span><br><span class="line">               //获取node的前节点</span><br><span class="line">               final Node p = node.predecessor();</span><br><span class="line">               //如果p的前节点就是头结点 尝试获取锁</span><br><span class="line">               if (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                   //设置当前node为头结点</span><br><span class="line">                   setHead(node);</span><br><span class="line">                   p.next = null; // help GC</span><br><span class="line">                   return interrupted;</span><br><span class="line">               &#125;</span><br><span class="line">               //做一些阻塞前的准备操作</span><br><span class="line">               if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                   //阻塞 唤醒后检查中断标志位</span><br><span class="line">                   parkAndCheckInterrupt())</span><br><span class="line">                   interrupted = true;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; catch (Throwable t) &#123;</span><br><span class="line">           cancelAcquire(node);</span><br><span class="line">           throw t;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<h5 id="2、FairSync-公平锁"><a href="#2、FairSync-公平锁" class="headerlink" title="2、FairSync 公平锁"></a>2、FairSync 公平锁</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">final void lock() &#123;</span><br><span class="line">        acquire(1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//acquire的实现与非公平锁相同</span><br><span class="line">//看一下公平锁的tryAcquire</span><br><span class="line">protected final boolean tryAcquire(int acquires) &#123;</span><br><span class="line">        final Thread current = Thread.currentThread();</span><br><span class="line">        int c = getState();</span><br><span class="line">        if (c == 0) &#123;</span><br><span class="line">            //与非公平锁不一致的地方在于 这里需要</span><br><span class="line">            //判断当前线程前是否还有其他节点</span><br><span class="line">            //如果有其它节点则需要到后面的阻塞排队逻辑</span><br><span class="line">            if (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">                compareAndSetState(0, acquires)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(current);</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">            int nextc = c + acquires;</span><br><span class="line">            if (nextc &lt; 0)</span><br><span class="line">                throw new Error(&quot;Maximum lock count exceeded&quot;);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//判断头结点后的节点的线程是否为当前线程</span><br><span class="line">public final boolean hasQueuedPredecessors() &#123;</span><br><span class="line">    // The correctness of this depends on head being initialized</span><br><span class="line">    // before tail and on head.next being accurate if the current</span><br><span class="line">    // thread is first in queue.</span><br><span class="line">    Node t = tail; // Read fields in reverse initialization order</span><br><span class="line">    Node h = head;</span><br><span class="line">    Node s;</span><br><span class="line">    return h != t &amp;&amp;</span><br><span class="line">        ((s = h.next) == null || s.thread != Thread.currentThread());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="3、unLock-解锁"><a href="#3、unLock-解锁" class="headerlink" title="3、unLock 解锁"></a>3、unLock 解锁</h5><p>解锁并唤醒队列中下一个不为null的节点</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">public void unlock() &#123;</span><br><span class="line">        sync.release(1);</span><br><span class="line">    &#125;</span><br><span class="line">    public final boolean release(int arg) &#123;</span><br><span class="line">        if (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;//当前执行的节点，当前的head结点指向的是在执行的线程，</span><br><span class="line">            //如果后面还有其他结点需要唤醒，此时的head的status应该会是SINGAL，会继续走到unparkSuccessor()</span><br><span class="line">            if (h != null &amp;&amp; h.waitStatus != 0)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    protected final boolean tryRelease(int releases) &#123;</span><br><span class="line">            int c = getState() - releases;</span><br><span class="line">            if (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">                throw new IllegalMonitorStateException();</span><br><span class="line">            boolean free = false;</span><br><span class="line">            if (c == 0) &#123;</span><br><span class="line">                free = true;</span><br><span class="line">                setExclusiveOwnerThread(null);</span><br><span class="line">            &#125;</span><br><span class="line">            setState(c);</span><br><span class="line">            return free;</span><br><span class="line">    &#125;</span><br><span class="line">     private void unparkSuccessor(Node node) &#123;</span><br><span class="line">     </span><br><span class="line">        int ws = node.waitStatus;</span><br><span class="line">        if (ws &lt; 0)</span><br><span class="line">            node.compareAndSetWaitStatus(ws, 0);</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        //s.waitStatus &gt; 0说明节点为Cancel节点</span><br><span class="line">        if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">            s = null;</span><br><span class="line">            for (Node p = tail; p != node &amp;&amp; p != null; p = p.prev)</span><br><span class="line">                //从后往前遍历节点 找出不为null的节点</span><br><span class="line">                if (p.waitStatus &lt;= 0)</span><br><span class="line">                    s = p;</span><br><span class="line">        &#125;</span><br><span class="line">        if (s != null)</span><br><span class="line">            //唤醒下一个线程</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h5 id="4、Lock流程总结"><a href="#4、Lock流程总结" class="headerlink" title="4、Lock流程总结"></a>4、Lock流程总结</h5><p>调用lock方法，当为非公平锁时，只要有线程过来就尝试获取锁，如果获取成功（AQS的state==0 并且CAS写入成功）将自身设置为独占锁的拥有者 或者state != 0但当前独占锁就是自身（表示重入），获取锁成功并将state累加；如果获取失败就将自己设置到AQS队列的尾部，等待唤醒；当为公平锁时，与非公平锁的主要区别在于公平锁在执行tryAcquire时，需要加一个判断（当前节点是否还有其他节点），如果有其它节点则将自身添加到队列中等待唤醒；</p>
<h4 id="二、ReentrantLock的唤醒通知机制"><a href="#二、ReentrantLock的唤醒通知机制" class="headerlink" title="二、ReentrantLock的唤醒通知机制"></a>二、ReentrantLock的唤醒通知机制</h4><p>同Object的wait notify类似，ReentrantLock也有一套自己的唤醒等待机制；通过ReentrantLock的newCondition创建condition对象，调用condition的await实现等待、调用signal或者signalAll实现唤醒，例如下面的一个生产者消费者例子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">public class ProducterAndConsumerTest &#123;</span><br><span class="line">    private static Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;();</span><br><span class="line">    private static ReentrantLock lock = new ReentrantLock();</span><br><span class="line">    private static Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        new Thread(new ProducterRunnable()).start();</span><br><span class="line">        new Thread(new ConsumerRunnable()).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ProducterRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (queue.size() &gt;= 10) &#123;</span><br><span class="line">                        //当生产者队列已满 等待 并释放锁</span><br><span class="line">                        System.out.println(&quot;生产者车间已满&quot;);</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    queue.offer(1);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    System.out.println(&quot;生产者生产了一个苹果&quot;);</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static class ConsumerRunnable implements Runnable &#123;</span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                lock.lock();</span><br><span class="line">                while (true) &#123;</span><br><span class="line">                    if (queue.size() &lt;= 0) &#123;</span><br><span class="line">                        //当队列为空 将消费者等待 并释放锁</span><br><span class="line">                        System.out.println(&quot;消费者都吃完了&quot;);</span><br><span class="line">                        condition.await();</span><br><span class="line">                    &#125;</span><br><span class="line">                    System.out.println(&quot;消费者吃了一个苹果&quot;);</span><br><span class="line">                    condition.signal();</span><br><span class="line">                    queue.poll();</span><br><span class="line">                    Thread.sleep(1000);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line"></span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p>参考文档：<a href="https://www.jianshu.com/p/feb17d1becb0" target="_blank" rel="noopener">https://www.jianshu.com/p/feb17d1becb0</a></p>

    </div>
    
    <div class="post-footer">
        <div>
            
            转载声明：
            商业转载请联系作者获得授权,非商业转载请注明出处 © <a href="" target="_blank">Snippet</a>
            
            
        </div>
        <div>
            
        </div>
    </div>
</article>
<div class="article-nav prev-next-wrap clearfix">
    
    <a href="/2019/11/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/" class="pre-post btn btn-default" title='并发编程'>
        <i class="fa fa-angle-left fa-fw"></i><span class="hidden-lg">上一篇</span>
        <span class="hidden-xs">
            并发编程</span>
    </a>
    
    
    <a href="/2019/11/06/%E8%B0%A6%E8%B0%A6%E5%90%9B%E5%AD%90/" class="next-post btn btn-default" title='谦谦君子，温润如玉'>
        <span class="hidden-lg">下一篇</span>
        <span class="hidden-xs">
            谦谦君子，温润如玉</span><i class="fa fa-angle-right fa-fw"></i>
    </a>
    
</div>

<div id="comments">
    

<div id="vcomments" class="valine"></div>
<script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
<script src="/assets/valine.min.js"></script>
<script>
new Valine({
    av: AV,
    el: '#vcomments',
    appId: 'xOKV9J4UeQAtVkvnJC7Kq2Jn-gzGzoHsz',
    appKey: 'erIpQac4azoCmgfBB7Dl9maa',
    placeholder: '说点什么吧',
    notify: false,
    verify: true,
    avatar: 'mm',
    meta: 'nick,mail'.split(','),
    pageSize: '10',
    path: window.location.pathname,
    lang: 'en'.toLowerCase()
})
</script>


</div>

                </main>
                
                    <aside id="article-toc" role="navigation" class="col-md-4">
    <div class="widget">
        <h3 class="title">
            Table of Contents
        </h3>
        
        <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock源码分析"><span class="toc-text">ReentrantLock源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一、构造函数"><span class="toc-text">一、构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、AQS数据结构分析"><span class="toc-text">二、AQS数据结构分析</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、node提供的常量"><span class="toc-text">1、node提供的常量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、node提供的变量"><span class="toc-text">2、node提供的变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、Lock"><span class="toc-text">二、Lock</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1、NonfairSync-非公平锁"><span class="toc-text">1、NonfairSync 非公平锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2、FairSync-公平锁"><span class="toc-text">2、FairSync 公平锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3、unLock-解锁"><span class="toc-text">3、unLock 解锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4、Lock流程总结"><span class="toc-text">4、Lock流程总结</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二、ReentrantLock的唤醒通知机制"><span class="toc-text">二、ReentrantLock的唤醒通知机制</span></a></li></ol></li></ol>
        
    </div>
</aside>
                
            </div>
        </div>
    </section>
    <footer class="main-footer">
    <div class="container">
        <div class="row">
        </div>
    </div>
</footer>
<a id="back-to-top" class="icon-btn hide">
    <i class="fa fa-chevron-up"></i>
</a>
    <div class="copyright">
    <div class="container">
        <div class="row">
            <div class="col-sm-12">
                <div class="busuanzi">
    
</div>
            </div>
            <div class="col-sm-12">
                <span>Copyright &copy;
                    2017
                    
                </span> |
                <span>
                    Powered by <a href="//hexo.io" class="copyright-links" target="_blank" rel="nofollow">Hexo</a>
                </span> |
                <span>
                    Theme by <a href="//github.com/shenliyang/hexo-theme-snippet.git" class="copyright-links" target="_blank" rel="nofollow">Snippet</a>
                </span>
            </div>
        </div>
    </div>
</div>



<script src="/js/app.js?rev=@@hash"></script>
</body>
</html>