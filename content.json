{"meta":{"title":"zljzy","subtitle":null,"description":null,"author":"JunHui Gao","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"页面的表格打印成excel导出","slug":"页面table导出为excel","date":"2020-01-10T10:15:52.967Z","updated":"2020-01-10T10:16:32.618Z","comments":true,"path":"2020/01/10/页面table导出为excel/","link":"","permalink":"http://yoursite.com/2020/01/10/%E9%A1%B5%E9%9D%A2table%E5%AF%BC%E5%87%BA%E4%B8%BAexcel/","excerpt":"","text":"今天有个朋友说要帮忙开发一个页面表格打印excel的功能，因为他每天把页面的table粘贴复制到excel太累了，而且属于重复工作，完全是体力活，心神俱疲。我就勇敢的接下这个活了。 按照惯例，废话不多说，先贴示例代码 123456789101112131415function printExcle() &#123; var link = document.createElement(&quot;a&quot;); // 使用outerHTML属性获取整个table元素的HTML代码（包括&lt;table&gt;标签），然后包装成一个完整的HTML文档，设置charset为urf-8以防止中文乱码 var html = &quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=&apos;utf-8&apos; /&gt;&lt;/head&gt;&lt;body&gt;&quot; + html1 + &quot;&lt;/body&gt;&lt;/html&gt;&quot;; // 实例化一个Blob对象，其构造函数的第一个参数是包含文件内容的数组，第二个参数是包含文件类型属性的对象 console.log(html); var blob = new Blob([html], &#123; type: &quot;application/vnd.ms-excel&quot; &#125;); // 利用URL.createObjectURL()方法为a元素生成blob URL link.href = window.URL.createObjectURL(blob); link.download = &quot;demoExcel.xls&quot;; document.body.appendChild(link); link.click(); document.body.removeChild(link); window.URL.revokeObjectURL(link.href);&#125; 上面是我百度的js代码，本人请示可以导出页面tabel成excel，但是考虑的朋友非计算机专业人员，就开发了一个浏览器扩展程序，功能描述： 用户打开页面启用扩展功能鼠标点击table即可导出为excel123456789101112131415161718192021222324252627document.addEventListener(&apos;DOMContentLoaded&apos;, function () &#123; var divs = document.querySelectorAll(&apos;div&apos;); for (var i = 0; i &lt; divs.length; i++) &#123; divs[i].addEventListener(&apos;click&apos;, click); &#125; chrome.tabs.executeScript(null, &#123;code:` document.querySelectorAll(&apos;table&apos;).forEach(item =&gt; &#123; item.onclick = e =&gt; &#123; if (confirm(&quot;你确定导出为Excel吗？&quot;)) &#123; var link = document.createElement(&quot;a&quot;); // 使用outerHTML属性获取整个table元素的HTML代码（包括&lt;table&gt;标签），然后包装成一个完整的HTML文档，设置charset为urf-8以防止中文乱码 var html = &quot;&lt;html&gt;&lt;head&gt;&lt;meta charset=&apos;utf-8&apos; /&gt;&lt;/head&gt;&lt;body&gt;&quot; + item.outerHTML + &quot;&lt;/body&gt;&lt;/html&gt;&quot;; // 实例化一个Blob对象，其构造函数的第一个参数是包含文件内容的数组，第二个参数是包含文件类型属性的对象 var blob = new Blob([html], &#123; type: &quot;application/vnd.ms-excel&quot; &#125;); // 利用URL.createObjectURL()方法为a元素生成blob URL link.href = window.URL.createObjectURL(blob); link.download = &quot;tablePrintExcel.xls&quot;; document.body.appendChild(link); link.click(); document.body.removeChild(link); window.URL.revokeObjectURL(link.href); &#125; &#125; &#125;) `&#125;);&#125;);","categories":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}]},{"title":"Spring注解@PostConstruct","slug":"Spring注解@PostConstruct使用","date":"2020-01-10T09:41:58.759Z","updated":"2020-01-10T09:46:29.183Z","comments":true,"path":"2020/01/10/Spring注解@PostConstruct使用/","link":"","permalink":"http://yoursite.com/2020/01/10/Spring%E6%B3%A8%E8%A7%A3@PostConstruct%E4%BD%BF%E7%94%A8/","excerpt":"","text":"123456@PostConstruct该注解被用来修饰一个非静态的void（）方法。被@PostConstruct修饰的方法会在服务器加载Servlet的时候运行，并且只会被服务器执行一次。PostConstruct在构造函数之后执行，init（）方法之前执行。通常我们会是在Spring框架中使用到@PostConstruct注解 该注解的方法在整个Bean初始化中的执行顺序：Constructor(构造方法) -&gt; @Autowired(依赖注入) -&gt; @PostConstruct(注释的方法) 按照惯例，废话不多说，先贴示例代码 123456789101112@Componentpublic class test &#123; private static Logger logger = LoggerFactory.getLogger(test.class); @Autowired private User user; @PostConstruct private void initTest() &#123; &#125;","categories":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}],"keywords":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}]},{"title":"mybatis 批量更新数据的三种方法","slug":"mybatis-批量更新数据的三种方法","date":"2020-01-10T02:29:24.448Z","updated":"2020-01-10T09:50:08.441Z","comments":true,"path":"2020/01/10/mybatis-批量更新数据的三种方法/","link":"","permalink":"http://yoursite.com/2020/01/10/mybatis-%E6%89%B9%E9%87%8F%E6%9B%B4%E6%96%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95/","excerpt":"","text":"一、三种实现方式123456781、mysql数据库提供的case when条件判断变相的进行批量更新 示例：update test set name = case id when 1 then &quot;dgs&quot; when 2 then &quot;lr&quot; when 3 then &quot;g&quot; end where 1=1 and id =1 or id = 2 or id = 32、用for循环通过循环传过来的参数集合，拼接sql3、mysql提供的关键字ON DUPLICATE KEY UPDATE进行批量更新 二、第一种实现方式按照惯例，废话不多说，先贴示例代码12345678910111213141516&lt;update id=&quot;update&quot; parameterType=&quot;java.util.List&quot;&gt; update test &lt;trim prefix=&quot;set&quot; suffixOverrides=&quot;,&quot;&gt; &lt;trim prefix=&quot;name =case&quot; suffix=&quot;end,&quot;&gt; &lt;foreach collection=&quot;list&quot; item=&quot;i&quot; index=&quot;index&quot;&gt; &lt;if test=&quot;i.name!=null&quot;&gt; when id=#&#123;i.id&#125; then #&#123;i.name&#125; &lt;/if&gt; &lt;/foreach&gt; &lt;/trim&gt; &lt;/trim&gt; where &lt;foreach collection=&quot;list&quot; separator=&quot;or&quot; item=&quot;i&quot; index=&quot;index&quot; &gt; id=#&#123;i.id&#125; &lt;/foreach&gt;&lt;/update&gt; 三、第二种实现方式1234567891011&lt;update id=&quot;updateBatch&quot; parameterType=&quot;java.util.List&quot; &gt; &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; open=&quot;&quot; close=&quot;&quot; separator=&quot;;&quot;&gt; update test &lt;set&gt; &lt;if test=&quot;item.name != null&quot; &gt; name = #&#123;i.name&#125; &lt;/if&gt; &lt;/set&gt; where id = #&#123;item.id,jdbcType=BIGINT&#125; &lt;/foreach&gt; &lt;/update&gt; 四、第三种实现方式12345678910&lt;insert id=&quot;updateBatch&quot; parameterType=&quot;java.util.List&quot;&gt; insert into test(name,test_phone) VALUES &lt;foreach collection=&quot;list&quot; item=&quot;item&quot; index=&quot;index&quot; separator=&quot;,&quot;&gt; (#&#123;item.name,jdbcType=VARCHAR&#125;,#&#123;item.testPhone,jdbcType=VARCHAR&#125;) &lt;/foreach&gt; ON DUPLICATE KEY UPDATE id=VALUES(id), //使用这种方法可能会造成数据丢失，记得一定要加上id。 name = VALUES(name), name = VALUES(test_phone) //这里需要注意使用的是values(表字段名称) &lt;/insert&gt; 五、三种方式对比1234第一种方式sql的执行速度很快，但是mybatis里的循环过多。第二方式sql的执行速度也不错，但是大量数据的时候由于sql语句过多，可能会对数据库造成影响。第三种方式一般不建议使用，很多公司也是禁用的，因为会出现数据错乱问题，但是他的执行速度很快，这里有两个注意点，update后一定要带上id字段，values里面一定放的是，数据库字段名称。总结：建议使用第一种方法，数据量大的情况下可以分批更新。","categories":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}],"tags":[{"name":"mybatis","slug":"mybatis","permalink":"http://yoursite.com/tags/mybatis/"}],"keywords":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}]},{"title":"java内存模型","slug":"java内存模型","date":"2019-11-26T09:15:56.262Z","updated":"2020-01-09T09:31:54.425Z","comments":true,"path":"2019/11/26/java内存模型/","link":"","permalink":"http://yoursite.com/2019/11/26/java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"Java内存模型（本文简称JMM）一、构造函数12","categories":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"keywords":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}]},{"title":"并发编程","slug":"多线程的学习","date":"2019-11-26T08:46:23.027Z","updated":"2019-11-28T06:14:02.410Z","comments":true,"path":"2019/11/26/多线程的学习/","link":"","permalink":"http://yoursite.com/2019/11/26/%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"并发编程二、为什么要使用并发编程2004年，Intel宣布4GHz芯片的计划推迟到2005年，然后在2004年秋季，Intel宣布彻底取消4GHz的计划，也就是说摩尔定律的有效性超过了半个世纪戛然而止。但是，聪明的硬件工程师并没有停止研发的脚步，他们为了进一步提升计算速度，而不是再追求单独的计算单元，而是将多个计算单元整合到了一起，也就是形成了多核CPU。短短十几年的时间，家用型CPU,比如Intel i7就可以达到4核心甚至8核心。而专业服务器则通常可以达到几个独立的CPU，每一个CPU甚至拥有多达8个以上的内核。因此，摩尔定律似乎在CPU核心扩展上继续得到体验。因此，多核的CPU的背景下，催生了并发编程的趋势，通过并发编程的形式可以将多核CPU的计算能力发挥到极致，性能得到提升。 另外，在特殊的业务场景下先天的就适合于并发编程。比如在图像处理领域，一张1024X768像素的图片，包含达到78万6千多个像素。即时将所有的像素遍历一边都需要很长的时间，面对如此复杂的计算量就需要充分利用多核的计算的能力。又比如当我们在网上购物时，为了提升响应速度，需要拆分，减库存，生成订单等等这些操作，就可以进行拆分利用多线程的技术完成。面对复杂业务模型，并行程序会比串行程序更适应业务需求，而并发编程更能吻合这种业务拆分 。正是因为这些优点，使得多线程技术能够得到重视，也是一名CS学习者应该掌握的：1、充分利用多核CPU的计算能力；2、方便进行业务拆分，提升应用性能 2.1并发编程一定会使我们的程序运行的更快吗？答案是并不是，并发编程只有在一定的请求量或者计算量的时候才会显示出优势； 2.2 为什么有的时候多线程反而会变慢呢？我们知道os（操作系统）执行并发操作是采用的时间片轮转算法，简单的说就是线程1先执行10ms 然后线程B在执行10ms 然后线程A又执行了10ms 线程A执行完毕 线程B又开始执行到结束 我们可以发现这种执行的机制，会导致cpu一会执行A线程 一会执行B线程，这就导出了一个第一个导致多线程慢的因素：线程的上下文切花需要时间补充：Java创建多线程需要OS的干预，OS需要从用户态切换到核心态 这个过程很耗费时间 那么简单的理解就是：如果多线程执行的速度快于单线程执行的速度，那么我们可以理解为多线程一定会在执行前做一些准备，而单线程不需要，所以当任务数或者工作量并不大的时候单线程就会很有优势；但是当任务数上来后多线程的优势就体现出来了；二、并发编程的好处12","categories":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"keywords":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}]},{"title":"ReentrantLock源码分析","slug":"ReentrantLock源码分析","date":"2019-11-25T07:34:04.188Z","updated":"2020-01-10T05:53:31.542Z","comments":true,"path":"2019/11/25/ReentrantLock源码分析/","link":"","permalink":"http://yoursite.com/2019/11/25/ReentrantLock%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"ReentrantLock源码分析一、构造函数123456789ReentrantLock lock = new ReentrantLock();//里面的参数可指定是公平还是非公平锁 public ReentrantLock() &#123; sync = new NonfairSync(); &#125; //指定是当前是公平锁 还是非公平锁 public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); &#125; 继承关系 1234567static final class FairSync extends Sync &#123;&#125;static final class NonfairSync extends Sync &#123;&#125; abstract static class Sync extends AbstractQueuedSynchronizer&#123;&#125; public abstract class AbstractQueuedSynchronizer extends AbstractOwnableSynchronizer&#123;&#125; 二、AQS数据结构分析AQS（java.util.concurrent.locks.AbstractQueuedSynchronizer）是ReentrantLock实现线程排队等待的数据结构，本质是一个双向的FIFO队列； 1、node提供的常量12345678910111213141516/** Marker to indicate a node is waiting in shared mode */ static final Node SHARED = new Node();//共享模式，表示可以多个线程同时执行 /** Marker to indicate a node is waiting in exclusive mode */ static final Node EXCLUSIVE = null;//独占模式，表示只有一个线程能执行例如ReentrantLock；共享模式 多个线程可同时执行 例如Semaphore/CountDownLatch /** waitStatus value to indicate thread has cancelled. */ static final int CANCELLED = 1;//取消状态 表示这个节点被取消了 可能是主动取消或者被动取消，后续这个节点可能会被踢出队列 /** waitStatus value to indicate successor&apos;s thread needs unparking. */ static final int SIGNAL = -1;//通知后继节点 表示这个结点执行完成以后，需要通知唤醒后继的结点 /** waitStatus value to indicate thread is waiting on condition. */ static final int CONDITION = -2;//说明这个结点因为被某一个condition挂起了 /** * waitStatus value to indicate the next acquireShared should * unconditionally propagate. */ static final int PROPAGATE = -3;//在共享模式下，下一次获取锁后可以无限传播 2、node提供的变量123456waitStatus 当前结点的状态，默认是0，可以是CANCELL、SIGNAL 等prev 前继结点next 后继结点thread 对应的线程nextWaiter 下一个等待condition的结点state 状态；是一个int值，表示当前线程占用资源的数量；0表示空闲，没有线程占用；ReentrantLock的state表示线程重入锁的次数 二、Lock1、NonfairSync 非公平锁123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113public void lock() &#123; //当为非公平锁时 这里的lock会走NonfairSync下的lock函数 sync.lock(); &#125; final void lock() &#123; //利用CAS更新当前锁的状态 分析1 if (compareAndSetState(0, 1)) //设置当前线程为独占锁的拥有者 分析2 setExclusiveOwnerThread(Thread.currentThread()); else //如果CAS更新失败 获取锁 分析3 acquire(1); &#125; ===&gt;分析1 //AbstractQueuedSynchronizer下方法；通过CAS更新当前锁的状态 protected final boolean compareAndSetState(int expect, int update) &#123; return U.compareAndSwapInt(this, STATE, expect, update); &#125; ===&gt;分析2 //如果CAS更新成功，设置当前线程为独占锁的拥有者 //AbstractOwnableSynchronizer中方法； //AbstractOwnableSynchronizer把AQS包了一层；主要提供了一些获取、设置当前独占锁拥有者 protected final void setExclusiveOwnerThread(Thread thread) &#123; exclusiveOwnerThread = thread; &#125; ===&gt;分析3 //如果CAS更新失败 尝试获取锁 //AQS中的方法 public final void acquire(int arg) &#123; //如果获取锁失败 阻塞排队 if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) //如果排队也失败了 中断自己 selfInterrupt(); &#125; //tryAcquire是AQS中的方法，由子类具体实现；这里看NonfairSync的tryAcquire protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); 、 &#125; //acquires 是1 final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState();//获取state值 if (c == 0) &#123; //如果当前没有线程占用锁 通过CAS更新state标志位 //(这里也是非公平锁的一个原因 不判断前面是否有其它节点 直接CAS尝试拿锁) if (compareAndSetState(0, acquires)) &#123; //将当前线程设置为独占锁的拥有者 setExclusiveOwnerThread(current); return true; &#125; &#125; //如果state不为0 并且当前线程就是独占锁的拥有者（表示重入） else if (current == getExclusiveOwnerThread()) &#123; //累加state int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false; &#125; //新节点入队方法 private Node addWaiter(Node mode) &#123; Node node = new Node(mode); for (;;) &#123;//通过阻塞的方式将当前的node入队 Node oldTail = tail;//获取尾结点 if (oldTail != null) &#123; //将新节点插入到队列尾部 U.putObject(node, Node.PREV, oldTail); if (compareAndSetTail(oldTail, node)) &#123; oldTail.next = node; return node; &#125; &#125; else &#123; //队列为空 初始化队列 initializeSyncQueue(); &#125; &#125; &#125; //将当前线程入队阻塞 final boolean acquireQueued(final Node node, int arg) &#123; try &#123; boolean interrupted = false; for (;;) &#123; //获取node的前节点 final Node p = node.predecessor(); //如果p的前节点就是头结点 尝试获取锁 if (p == head &amp;&amp; tryAcquire(arg)) &#123; //设置当前node为头结点 setHead(node); p.next = null; // help GC return interrupted; &#125; //做一些阻塞前的准备操作 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; //阻塞 唤醒后检查中断标志位 parkAndCheckInterrupt()) interrupted = true; &#125; &#125; catch (Throwable t) &#123; cancelAcquire(node); throw t; &#125; &#125; 2、FairSync 公平锁12345678910111213141516171819202122232425262728293031323334353637383940final void lock() &#123; acquire(1);&#125;//acquire的实现与非公平锁相同//看一下公平锁的tryAcquireprotected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; //与非公平锁不一致的地方在于 这里需要 //判断当前线程前是否还有其他节点 //如果有其它节点则需要到后面的阻塞排队逻辑 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(&quot;Maximum lock count exceeded&quot;); setState(nextc); return true; &#125; return false;&#125;//判断头结点后的节点的线程是否为当前线程public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 3、unLock 解锁解锁并唤醒队列中下一个不为null的节点 12345678910111213141516171819202122232425262728293031323334353637383940414243public void unlock() &#123; sync.release(1); &#125; public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head;//当前执行的节点，当前的head结点指向的是在执行的线程， //如果后面还有其他结点需要唤醒，此时的head的status应该会是SINGAL，会继续走到unparkSuccessor() if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free; &#125; private void unparkSuccessor(Node node) &#123; int ws = node.waitStatus; if (ws &lt; 0) node.compareAndSetWaitStatus(ws, 0); Node s = node.next; //s.waitStatus &gt; 0说明节点为Cancel节点 if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node p = tail; p != node &amp;&amp; p != null; p = p.prev) //从后往前遍历节点 找出不为null的节点 if (p.waitStatus &lt;= 0) s = p; &#125; if (s != null) //唤醒下一个线程 LockSupport.unpark(s.thread); &#125; 4、Lock流程总结调用lock方法，当为非公平锁时，只要有线程过来就尝试获取锁，如果获取成功（AQS的state==0 并且CAS写入成功）将自身设置为独占锁的拥有者 或者state != 0但当前独占锁就是自身（表示重入），获取锁成功并将state累加；如果获取失败就将自己设置到AQS队列的尾部，等待唤醒；当为公平锁时，与非公平锁的主要区别在于公平锁在执行tryAcquire时，需要加一个判断（当前节点是否还有其他节点），如果有其它节点则将自身添加到队列中等待唤醒； 二、ReentrantLock的唤醒通知机制同Object的wait notify类似，ReentrantLock也有一套自己的唤醒等待机制；通过ReentrantLock的newCondition创建condition对象，调用condition的await实现等待、调用signal或者signalAll实现唤醒，例如下面的一个生产者消费者例子： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758public class ProducterAndConsumerTest &#123; private static Queue&lt;Integer&gt; queue = new ArrayDeque&lt;&gt;(); private static ReentrantLock lock = new ReentrantLock(); private static Condition condition = lock.newCondition(); public static void main(String[] args) &#123; new Thread(new ProducterRunnable()).start(); new Thread(new ConsumerRunnable()).start(); &#125; private static class ProducterRunnable implements Runnable &#123; @Override public void run() &#123; try &#123; lock.lock(); while (true) &#123; if (queue.size() &gt;= 10) &#123; //当生产者队列已满 等待 并释放锁 System.out.println(&quot;生产者车间已满&quot;); condition.await(); &#125; queue.offer(1); condition.signal(); System.out.println(&quot;生产者生产了一个苹果&quot;); Thread.sleep(1000); &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125; private static class ConsumerRunnable implements Runnable &#123; @Override public void run() &#123; try &#123; lock.lock(); while (true) &#123; if (queue.size() &lt;= 0) &#123; //当队列为空 将消费者等待 并释放锁 System.out.println(&quot;消费者都吃完了&quot;); condition.await(); &#125; System.out.println(&quot;消费者吃了一个苹果&quot;); condition.signal(); queue.poll(); Thread.sleep(1000); &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; lock.unlock(); &#125; &#125; &#125;&#125; 参考文档：https://www.jianshu.com/p/feb17d1becb0","categories":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}],"tags":[{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"}],"keywords":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}]},{"title":"谦谦君子，温润如玉","slug":"谦谦君子","date":"2019-11-06T09:19:31.698Z","updated":"2020-01-09T09:32:51.491Z","comments":true,"path":"2019/11/06/谦谦君子/","link":"","permalink":"http://yoursite.com/2019/11/06/%E8%B0%A6%E8%B0%A6%E5%90%9B%E5%AD%90/","excerpt":"","text":"1.与君共勉1234慧极必伤情深不寿强极则辱谦谦君子，温润如玉","categories":[{"name":"health","slug":"health","permalink":"http://yoursite.com/categories/health/"}],"tags":[{"name":"养生","slug":"养生","permalink":"http://yoursite.com/tags/%E5%85%BB%E7%94%9F/"}],"keywords":[{"name":"health","slug":"health","permalink":"http://yoursite.com/categories/health/"}]},{"title":"如何保持身体健康","slug":"如何保持身体健康","date":"2019-11-05T08:21:00.455Z","updated":"2019-11-06T07:08:11.492Z","comments":true,"path":"2019/11/05/如何保持身体健康/","link":"","permalink":"http://yoursite.com/2019/11/05/%E5%A6%82%E4%BD%95%E4%BF%9D%E6%8C%81%E8%BA%AB%E4%BD%93%E5%81%A5%E5%BA%B7/","excerpt":"","text":"1、保持心情愉悦123451.多读书，多看报，少吃零食，多睡觉2.多运动3.听轻量级音乐4.定时清理自己的情绪5.定时扔掉长时间不用的东西","categories":[{"name":"health","slug":"health","permalink":"http://yoursite.com/categories/health/"}],"tags":[{"name":"养生","slug":"养生","permalink":"http://yoursite.com/tags/%E5%85%BB%E7%94%9F/"}],"keywords":[{"name":"health","slug":"health","permalink":"http://yoursite.com/categories/health/"}]},{"title":"idea的快捷键大全","slug":"idea的快捷键大全","date":"2019-11-05T07:41:01.266Z","updated":"2019-11-06T07:08:35.440Z","comments":true,"path":"2019/11/05/idea的快捷键大全/","link":"","permalink":"http://yoursite.com/2019/11/05/idea%E7%9A%84%E5%BF%AB%E6%8D%B7%E9%94%AE%E5%A4%A7%E5%85%A8/","excerpt":"","text":"常用快捷键1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465Ctrl+Shift + Enter，语句完成“！”，否定完成，输入表达式时按 “！”键Ctrl+E，最近的文件Ctrl+Shift+E，最近更改的文件Shift+Click，可以关闭文件Ctrl+[ OR ]，可以跑到大括号的开头与结尾Ctrl+F12，可以显示当前文件的结构Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Ctrl+N，可以快速打开类Ctrl+Shift+N，可以快速打开文件Alt+Q，可以看到当前方法的声明Ctrl+P，可以显示参数信息Ctrl+Shift+Insert，可以选择剪贴板内容并插入Alt+Insert，可以生成构造器/Getter/Setter等Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catchCtrl+Enter，导入包，自动修正Ctrl+Alt+L，格式化代码Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作Ctrl+Alt+O，优化导入的类和包Ctrl+R，替换文本Ctrl+F，查找文本Ctrl+Shift+Space，自动补全代码Ctrl+空格，代码提示（与系统输入法快捷键冲突）Ctrl+Shift+Alt+N，查找类中的方法或变量Alt+Shift+C，最近的更改Alt+Shift+Up/Down，上/下移一行Shift+F6，重构 – 重命名Ctrl+X，删除行Ctrl+D，复制行Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Ctrl+J，自动代码（例如：serr）Ctrl+Alt+J，用动态模板环绕Ctrl+H，显示类结构图（类的继承层次）Ctrl+Q，显示注释文档Alt+F1，查找代码所在位置Alt+1，快速打开或隐藏工程面板Ctrl+Alt+left/right，返回至上次浏览的位置Alt+left/right，切换代码视图Alt+Up/Down，在方法间快速移动定位Ctrl+Shift+Up/Down，向上/下移动语句F2 或 Shift+F2，高亮错误或警告快速定位Tab，代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Alt+F3，逐个往下查找相同文本，并高亮显示Ctrl+Up/Down，光标中转到第一行或最后一行下Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）Ctrl+Alt+B，跳转到方法实现处Ctrl+Shift+Backspace，跳转到上次编辑的地方Ctrl+O，重写方法Ctrl+Alt+Space，类名自动完成Ctrl+Alt+Up/Down，快速跳转搜索结果Ctrl+Shift+J，整合两行Alt+F8，计算变量值Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本Ctrl+Alt+Shift+V，简单粘贴Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12，把焦点从编辑器移到最近使用的工具窗口Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器Ctrl+W，可以选择单词继而语句继而行继而函数Ctrl+Shift+W，取消选择光标所在词Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置Ctrl+I，实现方法Ctrl+Shift+U，大小写转化Ctrl+Y，删除当前行 其他用快捷键12345678910F9 resume programe 恢复程序Alt+F10 show execution point 显示执行断点F8 Step Over 相当于eclipse的f6 跳到下一步F7 Step Into 相当于eclipse的f5就是 进入到代码Alt+shift+F7 Force Step Into 这个是强制进入代码Shift+F8 Step Out 相当于eclipse的f8跳到下一个断点，也相当于eclipse的f7跳出函数Atl+F9 Run To Cursor 运行到光标处ctrl+shift+F9 debug运行java类ctrl+shift+F10 正常运行java类alt+F8 debug时选中查看值","categories":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}],"tags":[{"name":"idea","slug":"idea","permalink":"http://yoursite.com/tags/idea/"}],"keywords":[{"name":"tool","slug":"tool","permalink":"http://yoursite.com/categories/tool/"}]},{"title":"四川红油的做法","slug":"四川红油的做法","date":"2019-11-05T07:36:32.565Z","updated":"2020-01-10T10:03:24.892Z","comments":true,"path":"2019/11/05/四川红油的做法/","link":"","permalink":"http://yoursite.com/2019/11/05/%E5%9B%9B%E5%B7%9D%E7%BA%A2%E6%B2%B9%E7%9A%84%E5%81%9A%E6%B3%95/","excerpt":"","text":"初来四川，被红油惊呆掉的程序员，爱它就要学会它的精神，我请教了很多同事和饭店大妈，本人亲自尝试做过，方法可行，与君共享。 1、材料准备121.辣椒面、辣椒块（红辣椒剁小块）、花椒、大奎、葱、姜、芝麻2.菜籽油（没有菜籽油的可以用其他植物油代替，最好吃的还是菜籽油。） 2、制作过程121.把准备的材料放到盆里（注意这里是钢盆，因为油热，有些碗可以会被支撑不住，安全第一）2.把油烧热（300°），有冒烟中等烟量，将油稍微冷却后倒入盆里面（注意这里的盆很烫，不要用手触碰），等10分钟后完全冷却就可以享用美食了 3.红油的吃法121、川味美食里，红油抄手，钵钵鸡，夫妻肺片，等美食，红油是最基本食材元素。2、日常生活中，家里调制凉菜，炒菜都可以使用红油。 4、为什么要吃红油121、红油看着很红，但是吃着不辣，特别香，外地小伙伴来到成都一定要勇敢尝试。2、入乡随俗，由于西南地区，空气湿度比较大，吃红油可以有效的排除身体里面的湿气。","categories":[{"name":"food","slug":"food","permalink":"http://yoursite.com/categories/food/"}],"tags":[{"name":"红油","slug":"红油","permalink":"http://yoursite.com/tags/%E7%BA%A2%E6%B2%B9/"}],"keywords":[{"name":"food","slug":"food","permalink":"http://yoursite.com/categories/food/"}]},{"title":"hexo增加新菜单，文件归类","slug":"hexo增加新菜单，文件归类","date":"2019-11-04T10:26:11.343Z","updated":"2019-11-06T07:08:27.861Z","comments":true,"path":"2019/11/04/hexo增加新菜单，文件归类/","link":"","permalink":"http://yoursite.com/2019/11/04/hexo%E5%A2%9E%E5%8A%A0%E6%96%B0%E8%8F%9C%E5%8D%95%EF%BC%8C%E6%96%87%E4%BB%B6%E5%BD%92%E7%B1%BB/","excerpt":"","text":"1.修改scaffolds目录下的post.md模板1234567模板文件内部不要保留注释部分,关键词后面请使用英文冒号title: &#123;&#123; title &#125;&#125; // 标题date: &#123;&#123; date &#125;&#125; // 时间categories: [&apos;分类1&apos;,&apos;分类2&apos;] // 分类tags: [&apos;标签1&apos;,&apos;标签2&apos;] // 标签comments: false // 是否开启评论img: // 自定义缩略图 2.编辑_config.yml,找到menu将添加新的菜单food123456789// 不做文章归类新建菜单 favorite - page: food directory: favorite/ icon: fa-star// 做文章归类新建菜单 favorite - page: food directory: categories/food icon: fa-star 3.添加food对应的中文翻译12345如果你用的时中文，即你使用的语言是 zh-CN，那么你就需要在themes主题下找到你安装的主题里找到languages文件夹，里面有个zh-CN.yml，用编辑器打开这个文件，添加food对应的中文翻译food: 美食 4.编写文章demo1234title: democategories:- foodtags:","categories":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}],"keywords":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}]},{"title":"Hexo+Github搭建个人博客","slug":"Hexo+Github搭建个人博客","date":"2019-10-23T07:19:40.646Z","updated":"2019-11-06T07:08:22.470Z","comments":true,"path":"2019/10/23/Hexo+Github搭建个人博客/","link":"","permalink":"http://yoursite.com/2019/10/23/Hexo+Github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"Hexo+Github搭建个人博客一、为什么要建立个人博客12341.写博客可以检验你对一个知识点的理解程度。2.可以记录你的技术成长之路，找到你的技能短板。3.长时间书写博客，可以提高个人的写作水平4.分享可以提高的成就感，保持你的求知欲。 二、安装必备软件1、Nodejs环境、git环境安装1关于Nodejs、git环境的安装，自行百度。（个人建议如果你两个软件都没有安装好，就不要往下看了，千里之行始于足下。） 2、Hexo安装官网地址：https://hexo.io/zh-cn/docs/configuration 123456用nodeJs命令安装Hexo模块1、npm install hexo-cli -g (安装Hexo模块)2、hexo init blog (通过hexo创建一个blog项目)3、cd blog 4、npm install5、Hexo service (开发服务) 四、使用github pages在github上建立一个项目。（项目名称必须是{github用户名.github.io}） 三、配置git信息（方便hexo和github通过ssh通信）1、设置git的user和email:12git config --global user.name &quot;demo&quot;git config --global user.email &quot;1126669077@qq.com&quot; 2、查看是否设置成功12git config --global user.namegit config --global user.email 3、生成密钥1234ssh-keygen -t rsa -C &quot;1126669077@qq.com&quot;在/user/用户名/.ssh/目录下会生成两个文件id_rsa和id_rsa.pub文件将id_rsa.pub里的内容配置到github项目的Deploy keys里 五、配置Deployment123456在blog项目根目录下里找到_config.yml文件，找到Deployment，然后如下修改deploy: type: git repo: git@github.com:（github用户名）/（github用户名）.github.io.git branch: master 六、安装hexo-deployer-git自动部署发布工具1npm install hexo-deployer-git --save 七、生成静态文件部署到github123通过命令hexo clean &amp;&amp; hexo g &amp;&amp; hexo d 发布到githubhexo clean &amp;&amp; hexo g &amp;&amp; hexo d 通过连接就可以访问：（github用户名）.github.io 八、更改模板以及发布博客学习地址1https://hexo.io/zh-cn/docs/writing","categories":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}],"keywords":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-10-21T08:35:44.425Z","updated":"2019-11-06T06:27:32.566Z","comments":true,"path":"2019/10/21/hello-world/","link":"","permalink":"http://yoursite.com/2019/10/21/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}],"tags":[],"keywords":[{"name":"document","slug":"document","permalink":"http://yoursite.com/categories/document/"}]}]}